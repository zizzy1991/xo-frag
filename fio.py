



import mole
#import re
from math import sqrt
#import os.path
#import frag



def _readlinesFromFile(filename):
	with open(filename, 'r') as f:
		return f.read().split('\n')

def moleculeFromGau(filename):
	""" Load molecule from file containing:
		Charge Multiplicity
		AtomType x y z
		...
		AtomType x y z

		Atom1 [Atom2 Order] [Atom3 Order] ...
		Atom2 [...]
		...
		AtomN [...]
	"""
	s = _readlinesFromFile(filename)
	
	p = iter(s)
	m = mole.Molecule(filename)
	cm = p.next().split()
	m.charge = eval(cm[0])
	m.multiplicity = eval(cm[1])
	q = p.next()
	# atom coord part
	i = 0
	while q != '':
		# print q
		l = q.split()
		if l[0] in mole.ElementsTable:
			atp = mole.ElementsTable.index(l[0])
		else:
			atp = eval(l[0])
		x, y, z = eval(l[1]), eval(l[2]), eval(l[3])
		m.addAtom(mole.Atom(x, y, z, atp, i))
		i = i + 1
		q = p.next()
	q = p.next()

	# bond part
	while q != '':
		l = q.split()
		stp = eval(l[0])
		i = 0
		for i in range(len(l) / 2):
			b = eval(l[1 + i * 2])
			o = eval(l[2 + i * 2])
			i = i + 1
			m.addBond(mole.Bond(m.atoms[stp - 1], m.atoms[b - 1], o))
		q = p.next()
	if len(m.bonds) == 0:
		m._rebond()
	return m

def moleculeFromGjf(filename):
	''' Load molecule from gjf/com file
		method: form a gau file from the second \\n\\n to the end of 
			this gjf/com file
	'''
	with open(filename, 'r') as f:
		a = f.read()
		a = a.split('\n\n')[2:]
		s = ''
		for i in a:
			s = s + i + '\n\n'
	with open(filename[:-3] + 'gau', 'w') as f:
		f.write(s)
	return moleculeFromGau(filename[:-3] + 'gau')

def moleculeFromFile(filename):
	""" Load molecule from file containing:
	Line|  Content
	----+------------------------
	0001|  Title
	0002|  Charge Multiplicity
	0003|  AtomType X Y Z
	0004|  AtomType X Y Z
	0005|  ...
	"""
	# TODO support both number and chars to describe atomtype
	# NOTE use split('\n') 'foo\nbar\n'.split('\n') -> ['foo','bar',''] 
	
	
	s = _readlinesFromFile(filename)
	p = iter(s)
	m = mole.Molecule(p.next())  # create a molecule
	m.charge = eval(p.next())    # define charge and multiplicity
	m.multiplicity = eval(p.next())
	for i in range(len(s) / 4):  # len(s)/4 => amount of atoms
		tp, x, y, z = (p.next(), eval(p.next()), eval(p.next()), eval(p.next()))
		if tp[0] not in range(100): tp[0] = mole.ElementsTable.index(tp[0]) 
		a = mole.Atom(x, y, z, tp, i)
		m.addAtom(a)

	m.finish()	#generate bonds, bondmap, atommap. etc
	return m
		
def bondArrayFromFile(filename):
	""" read in gauss-type connetion 
	    atom_id [atom_id bond_order]*
		atom_id [atom_id bond_order]*
		...
		# int atom_id, real bond_order

		return list of tuple (atom_id, atom_id, bond_order)
	"""
	s = _readlinesFromFile(filename)
	m = []
	if s == []: return m
	for line in s:
		for i, a in enumerate(s):
			if i == 0: 
				x = eval(a)
			elif i % 2 == 1:
				y = eval(a)
			else: m.append((x, y, eval(a)))
	return m

def connectionMatrixFromBondArray(b_array):
	""" return connection matrix from bond_array with the form below:
	[(atom1_id, atom2_id, bond_order), ... ]
	"""
	a_max = b_array[-1][0] + 1  # idx of last atom + 1
	m = [[0] * a_max] * a_max
	for x, y, o in b_array:
		m[x][y] = o
		m[y][x] = o
	return m


def connectionMatrixFromFile(filename):
	""" return connection matrix from file:
		atom_id [atom_id order] [atom_id order] ...
		atom_id [atom_id order] [atom_id order] ...
		...
	"""
	return connectionMatrixFromBondArray(bondArrayFromFile(filename))

def forceMatrixFromGaussOutput(filename):
	""" Get force matrix from gauss-log-file, returning a list
	contanning (index, f_x, f_y, f_z), make sure your job-file
	has done opt or force
	"""
	s = _readlinesFromFile(filename)
	p = 0
	#find last force matrix
	for i, x in enumerate(s):
		if x == ' Center     Atomic                   Forces (Hartrees/Bohr)':
			p = i
	p = p + 3  # skip lines "Number Number X Y Z" and " ----- "
	m = []
	if p != 3:
		while s[p][1] != '-':  # until s[p] == ' ---..--- ' 
			a = s[p].split()
			idx, x, y, z = (eval(a[0]), eval(a[2]), eval(a[3]), eval(a[4]))
			#atom number, force at x, y, z
			m.append((idx, x, y, z))
			p = p + 1
	return m

def forceErrorMatrixFromForceMatrix(m1, m2):
	''' get force error from two force matrix, m1 and m2
	which generated by forceMatrixFromGaussOutput(...) or other ways
	subjected, m = [(index, f_x, f_y, f_z) ...]
	'''
	fmat = []
	if len(m1) == len(m2):
		for i in range(len(m1)):
			fmat.append((m1[i][0], m2[i][1] - m1[i][1], m2[i][2] - m1[i][2], m2[i][3] - m1[i][3]))
	return fmat

def forceErrorMatrixFromGaussOutput(f1, f2):
	''' get force error from two gauss(or -like) output file, f1 and f2
	which have done "force"
	'''
	m1 = forceMatrixFromGaussOutput(f1)
	m2 = forceMatrixFromGaussOutput(f2)
	return forceErrorMatrixFromMatrix(m1, m2)

def RMS(lst):
	''' root mean square
	'''
	n = len(lst)
	avg = 1.0 / n * sum(lst)
	rms = sqrt(1.0 / (n - 1) * sum([(x - avg)**2 for x in lst]))
	return rms




typeConverter = {
		'gau': moleculeFromGau, 
		'gjf': moleculeFromGjf,
		'com': moleculeFromGjf,
		'xyz': moleculeFromGau
		}
